% -*- latex -*-
\documentclass[14pt, notes=hide]{beamer}

\usepackage{lmodern}


\usepackage[autogenerated]{ucs}
\include{unicodedefs}

\newcommand{\trc}[1]{#1^{\times}}
\DeclareMathOperator{\overlap}{Overlap}
\DeclareMathOperator{\tc}{TC}
%include agda.fmt

%include Definitions.lagda

\title{An Agda proof of the correctness of Valiant's algorithm for CF parsing}
\author{Thomas B{\aa}{\aa}th Sj{\"o}blom}
\institute{Chalmers University of Technology}
\date{}

\definecolor{darkgreen}{rgb}{0,0.4,0}

\begin{document}
\begin{frame}               % 1
\titlepage

\end{frame} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Overview}     % 2
\begin{itemize}
\item Parsing
  \begin{itemize}
  \item What is Parsing?
  \item Grammars
  \item Chart parsing % tie in to algebra
  \item Relation to transitive closure
  \end{itemize}
\item Valiant's Algorithm
  \begin{itemize}
  \item Motivation, then and now
  \item The algorithm
  \end{itemize}
\item Agda
  \begin{itemize}
  \item Introduction to Agda
  \item Implementation of Valiant's algorithm
  \item Sketch of Agda proof of Valiant's algorithm
  \end{itemize}  
\end{itemize}
% introduction
% example

% chart parsing
% transitive closure
% specification of transitive closure
\end{frame}


%\begin{frame}{Parsing}{Introduction}  % 3
% adding structure
%Parsing is adding structural information to a sequence of tokens.
% applications in compiler design, bioinformatics and computational linguistics
%\pause
% example
%\begin{equation*}
%  5 + 3 \times 2 + 7 \times (1 + 9) + 6
%\end{equation*}
% relevant to evaluating 
% numbers are factors
% 

% is the string generated by the grammar?
% introduction
% example
% uses
% why algebra? unified names

% chart parsing
% transitive closure
% specification of transitive closure
%\end{frame}


\begin{frame}{Parsing}{Introduction} % 4
\begin{itemize}
\item A grammar is a tuple $(N, \Sigma, P, S)$, where
  \begin{itemize}
  \item $N$ is the set of nonterminals.
  \item $\Sigma$ is the set of terminals, with $\Sigma \cap N = \emptyset$.
  \item $P$ is the set of production rules, each of the form $(\Sigma \cup N)^*N(\Sigma \cup N)^* \to (\Sigma \cup N)^*$
  \item $S \in N$ is the start symbol.
  \end{itemize}
\pause
\item We only consider grammars where the production rules are of the form (Chomsky normal form)
  \begin{itemize}
  \item $A \to BC$, where $A$, $B$, $C \in N$.
  \item $A \to \alpha$, where $A \in N$, $\alpha \in \Sigma$.
  \end{itemize}
\end{itemize}
\pause
Given a string, we want to see whether it can be generated from the start symbol, that is, whether there is a sequence of 
\end{frame}

\begin{frame}{Parsing}{Parse charts}
  Given a string of length $n$, we can make a matrix of all intermediate results into a matrix:
  \begin{equation*}
    \trc{C} = \begin{pmatrix}
      0 & a_{1 2} & a_{1 3} & \hdots & a_{1 n} \\
      0 & 0      & a_{2 3}  & \ldots & a_{2 n} \\
      \vdots & \vdots &\ddots & \ldots & \vdots\\
      0      & 0      & 0      & \ldots &a_{n-1 n}\\
      0      & 0      & 0      & \ldots &0
    \end{pmatrix}
  \end{equation*}
  where $a_{i j}$ is a set containing $A \in N$ iff $A$ generates the substring starting at the $i$th symbol, and ending at the $j$th.
\end{frame}

\begin{frame}{Parsing}{Parsing as transitive closure}
  \begin{itemize}
  \item We can multiply the sets by $x \cdot y = \{A : B \in x, C \in y, A \to BC \in P \}$.
    \pause
  \item Defining matrix multiplication as $(X \cdot Y)_{i j} = \bigcup_k X_{i k} Y_{k j}$ means that $(X \cdot Y)_{i j}$ contains $A$ if and only if $A$ is the product of a parse of the string from $i$ to $k$ in $X$ and from $k$ to $j$ in $Y$.
    \pause
    \item Hence, if $C$ is the matrix formed by placing the input just above the diagonal, the parse chart is the transitive closure of the input:
      \begin{equation*}
        \trc{C} = \trc{C}\trc{C} + C
      \end{equation*}
      \note{HUH, this is not very rigorous}
      A symbol is either an input symbol, or a combination of two parses.
  \end{itemize}
\end{frame}

\begin{frame}{Valiant's Algorithm}{Motivation} % 5
\begin{itemize}
  \item Then
    \begin{itemize}
    \item A theoretical algorithm for proving that parsing is as fast as matrix multiplication.
    \end{itemize}
  \item Now
    \begin{itemize}
    \item A practical (?) algorithm for parsing in parallel.
    \end{itemize}
  \item Idea
    \begin{itemize}
    \item Split string along the middle, recursively pars. Put together.
    \end{itemize}
\end{itemize}
\end{frame} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}{Valiant's Algorithm}{The Algorithm} % 6
To compute the transitive closure $\tc(C)$ of
\begin{equation*}
  C = 
  \begin{pmatrix}
    U_1 & R_1 & A   & B \\
        & L_1 & C   & D \\
        &     & U_2 & R_2 \\
        &     &     & L_2
  \end{pmatrix}
\end{equation*}
\pause
Recursively, compute the transitive closures
\begin{equation*}
  \begin{pmatrix}
    \trc{U_1} & \trc{R_1} \\
          & \trc{L_1}
  \end{pmatrix}
  = \tc
  \begin{pmatrix}
    U_1 & R_1 \\
        & L_1
  \end{pmatrix}, 
   \begin{pmatrix}
    \trc{U_2} & \trc{R_2} \\
          & \trc{L_2}
  \end{pmatrix}
   = \tc
  \begin{pmatrix}
    U_2 & R_2 \\
        & L_2
  \end{pmatrix}.
\end{equation*}
\end{frame} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Valiant's Algorithm}{The Algorithm} % 6

%% PERHAPS MAKE COOL ``ANIMATION''
Define $\overlap(X)$ to be the rectangular part of $\tc(X)$ and compute
\begin{align*}
  \trc{C} &= \overlap
  \begin{pmatrix}
    \trc{L_1} & C \\
        & \trc{U_2}
  \end{pmatrix}
  \\
  \trc{A} &= \overlap
  \begin{pmatrix}
    \trc{U_1} & A + \trc{R_1} \trc{C} \\
        & \trc{U_2}
  \end{pmatrix}
  \\
  \trc{D} &= \overlap
  \begin{pmatrix}
    \trc{L_1} & D + \trc{C} \trc{R_2} \\
        & \trc{L_2}
  \end{pmatrix}
  \\
  \trc{B} &= \overlap
  \begin{pmatrix}
    \trc{U_1} & B + \trc{R_1} \trc{D} + \trc{A} \trc{R_2} \\
        & \trc{L_2}
  \end{pmatrix}
\end{align*}
\pause
\end{frame} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{frame}{Valiant's Algorithm}{The Algorithm}  % 7
Putting things together, the transitive closure of $C$ is 
\begin{equation*}
  C = 
  \begin{pmatrix}
    \trc{U_1} & \trc{R_1} & \trc{A}   & \trc{B} \\
        & \trc{L_1} & \trc{C}   & \trc{D} \\
        &     & \trc{U_2} & \trc{R_2} \\
        &     &     & \trc{L_2}
  \end{pmatrix}
\end{equation*}
\end{frame} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{frame}{Agda} % 8
Agda is a dependently typed functional language.
\pause
\begin{code}
data ℕ : Set where
  zero  : ℕ
  suc   : ℕ → ℕ
\end{code}
\note{Syntax--unicode}
\pause
\vspace{-1cm}
\begin{code}
_+_ : ℕ → ℕ → ℕ
zero   + n = n
suc m  + n = suc (m + n)
\end{code}
\note{recursion, underscores}
%Agda is total. All Agda programs terminate.
\end{frame} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% intro:
% simple def of say nat
% function definition on nat

% define our matrices and triangles
% 
\begin{frame}{Agda}{Implementing Valiant's Algorithm} % 9
Datatype for matrices:
\begin{code}
data Split : Set where
  one  : Split
  bin  : Split → Split → Split
\end{code}
\begin{code}
data Mat : Split → Split → Set where
  sing  : R → Mat one one
  quad  : ∀ {r₁ r₂ c₁ c₂}  → Mat r₁ c₁ → Mat r₁ c₂ 
                           → Mat r₂ c₁ → Mat r₂ c₂ 
                           → Mat (bin r₁ r₂) (bin c₁ c₂)
\end{code}
\end{frame} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Agda}{Implementing Valiant's Algorithm} % 10
Datatype for triangles:
\begin{code}
data Tri : Split → Set where
  one  : Tri one
  tri  : ∀ {a b} → Tri a  → Mat a b
                          → Tri b 
                          → Tri (bin a b)
\end{code}
\end{frame} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}{Agda}{Implementing Valiant's Algorithm} % 11
Operations:
%format R+ = "\mathbin{+_{\!\!_R}}"
%format R* = "\mathbin{*_{\!\!_R}}"
% %format * = "\mathbin{*}"
\vspace{-0.5cm}
\begin{code}
_+_ : ∀ {a b} → Mat a b → Mat a b → Mat a b
sing x        + sing x'           = sing (x R+ x')
quad A B C D  + quad A' B' C' D'  = quad 
       (A + A') (B + B') 
       (C + C') (D + D')
\end{code}

\begin{code}
_*_ : ∀ {a b c} → Mat a b → Mat b c → Mat a c
sing x        * sing x'           = sing (x R* x')
quad A B C D  * quad A' B' C' D'  = quad 
       (A * A' + B * C') (A * B' + B * D') 
       (C * A' + D * C') (C * B' + D * D')
\end{code}
\end{frame} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}{Agda}{Implementing Valiant's Algorithm} % 11
%TODO remove or do for all:
%format U₁ˣ = U "_1^{" x "}" 
\begin{code}
overlap : ∀ {a b} → Tri a → Mat a b → Tri b → Mat a b
overlap one (sing x) one                      = sing x
overlap (tri U₁ˣ R₁ˣ L₁ˣ)  (quad A B C D) 
                           (tri U₂ˣ R₂ˣ L₂ˣ)  = quad  Aˣ  Bˣ 
                                                      Cˣ  Dˣ
  where  Cˣ  = overlap L₁ˣ C U₂ˣ
         Aˣ  = overlap U₁ˣ (A + R₁ˣ * Cˣ) U₂ˣ
         Dˣ  = overlap L₁ˣ (D + Cˣ * R₂ˣ) L₂ˣ
         Bˣ  = overlap U₁ˣ (B + R₁ˣ * Dˣ + Aˣ * R₂ˣ) L₂ˣ
\end{code}
\end{frame} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Agda}{Implementing Valiant's Algorithm} % 11
\begin{code}
v : ∀ {s} → Tri s → Tri s
v one          = one
v (tri U R L)  = tri U⁺ (overlap U⁺ R L⁺) L⁺
  where  U⁺  = v U
         L⁺  = v L
\end{code}
\end{frame} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}{Agda}{Proving things in Agda} % 12
The Curry--Howard correspondence:

A propositions can be seen as the type containing all proofs of the proposition.
\pause
\begin{code}
data _≤_ : ℕ → ℕ → Set where
  z≤n  : ∀ {n}            → zero ≤ n
  s≤s  : ∀ {m n} → m ≤ n  → suc m ≤ suc n
\end{code}
\note{what is indexed? type?, two different canonical proofs}
\pause
To prove something a proposition is to give an inhabitant of the type.
\end{frame} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Agda}{Specification of Valiant's algorithm} % 13
\begin{itemize}
\item A relation from triangles to triangles:
\begin{code}
_is-tc-of_ : ∀ {s} → Tri s → Tri s → Set
Cˣ is-tc-of C = Cˣ ≈ Cˣ * Cˣ + C
\end{code}
\pause
\item To prove the correctness, find an element of type
\begin{code}
∀ {s} {C : Tri s} → (v C) is-tc-of C
\end{code}
\end{itemize}
\end{frame} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Agda}{Sketch of proof} % 14
\begin{itemize}
  \item We pattern match on the |Tri|.
    \begin{itemize}
    \item |one|, should have type
      \begin{code}
        one ≈ one * one + one
      \end{code}
    \item |tri|, we get that the overlap function should satisfy
      \begin{code}
        Rˣ ≈ U * Rˣ +  R,
      \end{code}
      which when we expand it gives us exactly the definition of it.
    \end{itemize}
\end{itemize}
\end{frame} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
